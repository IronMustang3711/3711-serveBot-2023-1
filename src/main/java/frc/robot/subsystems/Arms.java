// Arms Subsystem controls Neo 500 Arm motor w/ 100:1, Neo-550 elbow motor w/ 210:1
// started with RobotBuilder Version: 5.0
// copied code from Smart Motion Example
// 29-Jan-2023  rod

// ?????  how is AllowedErr set???
// is maxRPM used???
// added 4 relay conntrol to drive RGB LED light string.
//// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
// REV smartMax code copied from Alternate Encoder example  %rod
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.AddressableLED;
import edu.wpi.first.wpilibj.AddressableLEDBuffer;



/**
 *
 */
public class Arms extends SubsystemBase {
  private static final int ArmID1 = 30; // %r1
  private static final int ElbowID = 31; // %r1
  private static final int ArmRatio = 100; // neo 500 42 cpr. 100:1 MaxPlanetary
  private static final int ElbowRatio = 210; // neo 550 42 cpr. 210:1 VexPlanetary

  private CANSparkMax arm_motor;
  private SparkMaxPIDController pidArm;
  private RelativeEncoder arm_encoder;

  public double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput, maxRPM, maxVel, minVel, maxAcc, allowedErr;

  // private CANSparkMax arm_motor2;
  private CANSparkMax elbow_motor;
  private SparkMaxPIDController pidElbow;
  private RelativeEncoder elbow_encoder;


  private AddressableLED m_led;
  private AddressableLEDBuffer m_ledBuffer;
  private DigitalOutput m_relay1;// relays 1-4
  private DigitalOutput m_relay2;
  private DigitalOutput m_relay3;
  private DigitalOutput m_relay4;
  
  public Arms() {
    // initialize SPARK MAX neo500 w/ 100:1
    arm_motor = new CANSparkMax(ArmID1, MotorType.kBrushless);
    arm_motor.restoreFactoryDefaults();
    pidArm = arm_motor.getPIDController();
    arm_encoder = arm_motor.getEncoder();
    // PID coefficients

    maxRPM = 5700; // ????????????????????????????

    // set PID coefficients
    pidArm.setP(0.00015); // proportional for Neo 500 arm
    pidArm.setI(0);
    pidArm.setD(0);
    pidArm.setIZone(0);
    pidArm.setFF(0);
    pidArm.setOutputRange(-1, 1);

    // set Motion Magic
    int smartMotionSlot = 0; // ????????????????????????????????
    pidArm.setSmartMotionMaxVelocity(4000, smartMotionSlot);
    pidArm.setSmartMotionMinOutputVelocity(0, smartMotionSlot);
    pidArm.setSmartMotionMaxAccel(2500, smartMotionSlot);
    pidArm.setSmartMotionAllowedClosedLoopError(allowedErr, smartMotionSlot); // ?????????????

    // Neo550 w/ 210:1
    elbow_motor = new CANSparkMax(ElbowID, MotorType.kBrushless);
    elbow_motor.restoreFactoryDefaults();
    elbow_motor.setSmartCurrentLimit( 30, 40);
    pidElbow = elbow_motor.getPIDController();
    elbow_encoder = elbow_motor.getEncoder();
    // set PID coefficients
    pidElbow.setP(0.00015); // proportional for Neo 550 arm
    pidElbow.setI(0.0000);
    pidElbow.setD(0);
    pidElbow.setIZone(0);
    pidElbow.setFF(0);
    pidElbow.setOutputRange(-1, 1);

    // set Motion Magic
    pidElbow.setSmartMotionMaxVelocity(10000, smartMotionSlot);
    pidElbow.setSmartMotionMinOutputVelocity(0, smartMotionSlot);
    pidElbow.setSmartMotionMaxAccel(10000, smartMotionSlot);
    pidElbow.setSmartMotionAllowedClosedLoopError(allowedErr, smartMotionSlot); // ?????????????

    // setup LED Sign control.  Copied for LED Example code 
    m_led = new AddressableLED(9);
    m_ledBuffer = new AddressableLEDBuffer(80);  // should be about 90 leds
    m_led.setLength(m_ledBuffer.getLength());

    // Set the data
    m_led.setData(m_ledBuffer);
    m_led.start();

    // setup LED relays.  Controlled by DIO 0-3 
    m_relay1 = new DigitalOutput(0);
    m_relay2 = new DigitalOutput(1);
    m_relay3 = new DigitalOutput(2);
    m_relay4 = new DigitalOutput(3);
  }

  @Override
  public void periodic() {
    // This method will be called once per scheduler run

  }

  @Override
  public void simulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

  }

  public void position(double armPose, double elbowPose) {
    // magic arm control
    pidArm.setReference(armPose, CANSparkMax.ControlType.kSmartMotion);

    SmartDashboard.putNumber("Arm Encoder", arm_encoder.getPosition());
    SmartDashboard.putNumber("Arm Current", arm_motor.getOutputCurrent());

    // elbow motor
    pidElbow.setReference(elbowPose, CANSparkMax.ControlType.kSmartMotion);

    SmartDashboard.putNumber("Elbow Encoder", elbow_encoder.getPosition());
    SmartDashboard.putNumber("Elbow Current", elbow_motor.getOutputCurrent());

  }

  public void drive(double armsSpeed, double elbowSpeed) {
    arm_motor.set(armsSpeed);
    elbow_motor.set(elbowSpeed);
  }

  public double getElbowPosition() {
    return elbow_encoder.getPosition();
  }

  public double getArmPosition() {
    return arm_encoder.getPosition();
  }

  public void setLEDRelays (boolean relay1,boolean relay2,
  boolean relay3,boolean relay4){
    m_relay1.set(relay1);
    m_relay2.set(relay2);
    m_relay3.set(relay3);
    m_relay4.set(relay4);
  }
  public void setSignLEDs (int mode){


    switch (mode) { 
      case 0:
      color(0,0,0);  // off
      break;
      case 1:
      color(255,0,0); // red
      break;
      case 2:
      color(0,255,0); // green
      break;
      case 3:
      color(0,0,255); // blue
      break;
      case 4:
      color(200,200,200);  // white
      break;
      case 5:
  //    rainbow();
      break;
    }

    // Set the LEDs
    m_led.setData(m_ledBuffer);
  }

  // private void rainbow() {
  //   // For every pixel
  //   for (var i = 0; i < m_ledBuffer.getLength(); i++) {
  //     // Calculate the hue - hue is easier for rainbows because the color
  //     // shape is a circle so only one value needs to precess
  //     final var hue = (m_rainbowFirstPixelHue + (i * 180 / m_ledBuffer.getLength())) % 180;
  //     // Set the value
  //     m_ledBuffer.setHSV(i, hue, 255, 128);
  //   }
  //   // Increase by to make the rainbow "move"
  //   m_rainbowFirstPixelHue += 3;
  //   // Check bounds
  //   m_rainbowFirstPixelHue %= 180;
  // }

  private void color(int red, int green, int blue) {
    // For every pixel
    for (var i = 0; i < m_ledBuffer.getLength(); i++) {
      m_ledBuffer.setRGB(i,red,green,blue);
    }

  }
}
